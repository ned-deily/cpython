#!/bin/sh
#
# Install/upgrade pip.
#

PYVER="@PYVER@"
PYMAJOR="@PYMAJOR@"
FWK="/Library/Frameworks/Python.framework/Versions/${PYVER}"
RELFWKBIN="../../..${FWK}/bin"

umask 022

"${FWK}/bin/python${PYVER}" -E -s -m ensurepip --upgrade

# bpo-33290: An earlier "pip3 install --upgrade pip" may have installed
#     a "pip" in the fw bin directory.  For a py3 install, remove it.

rm -f "${FWK}/bin/pip"

"${FWK}/bin/python${PYVER}" -E -s -Wi \
    "${FWK}/lib/python${PYVER}/compileall.py" -q -j0 \
    -f -x badsyntax \
    "${FWK}/lib/python${PYVER}/site-packages"

"${FWK}/bin/python${PYVER}" -E -s -Wi -O \
    "${FWK}/lib/python${PYVER}/compileall.py" -q -j0 \
    -f -x badsyntax \
    "${FWK}/lib/python${PYVER}/site-packages"

chgrp -R admin "${FWK}/lib/python${PYVER}/site-packages" "${FWK}/bin"
chmod -R g+w "${FWK}/lib/python${PYVER}/site-packages" "${FWK}/bin"

# Run the install certifi script since we have a pip.
# (Ignore errors for now.)

"${FWK}/bin/python${PYVER}" & << "EOF"

# install_certifi.py
#
# sample script to install or update a set of default Root Certificates
# for the ssl module.  Uses the certificates provided by the certifi package:
#       https://pypi.org/project/certifi/

import os
import os.path
import ssl
import stat
import subprocess
import sys

STAT_0o775 = ( stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR
             | stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP
             | stat.S_IROTH |                stat.S_IXOTH )

def main():
    openssl_dir, openssl_cafile = os.path.split(
        ssl.get_default_verify_paths().openssl_cafile)

    print(" -- pip install --upgrade certifi")
    subprocess.check_call([sys.executable,
        "-E", "-s", "-m", "pip", "install", "--upgrade", "certifi"])

    import certifi

    # change working directory to the default SSL directory
    os.chdir(openssl_dir)
    relpath_to_certifi_cafile = os.path.relpath(certifi.where())
    print(" -- removing any existing file or link")
    try:
        os.remove(openssl_cafile)
    except FileNotFoundError:
        pass
    print(" -- creating symlink to certifi certificate bundle")
    os.symlink(relpath_to_certifi_cafile, openssl_cafile)
    print(" -- setting permissions")
    os.chmod(openssl_cafile, STAT_0o775)
    print(" -- update complete")

if __name__ == '__main__':
    main()
EOF

# We do not know if the user selected the Python command-line tools
# package that installs symlinks to /usr/local/bin.  So we assume
# that the command-line tools package has already completed or was
# not selected and we will only install /usr/local/bin symlinks for
# pip et al if there are /usr/local/bin/python* symlinks to our
# framework bin directory.

if [ -d /usr/local/bin ] ; then
    (
        install_links_if_our_fw() {
            if [ "$(readlink -n ./$1)" = "${RELFWKBIN}/$1" ] ; then
                shift
                for fn ;
                do
                    if [ -e "${RELFWKBIN}/${fn}" ] ; then
                        rm -f ./${fn}
                        ln -s "${RELFWKBIN}/${fn}" "./${fn}"
                        chgrp -h admin "./${fn}"
                        chmod -h g+w "./${fn}"
                    fi
                done
            fi
        }

        cd /usr/local/bin

        # Create pipx.y and easy_install-x.y links if /usr/local/bin/pythonx.y
        #   is linked to this framework version
        install_links_if_our_fw "python${PYVER}" \
                                    "pip${PYVER}" "easy_install-${PYVER}"

        # Create pipx link if /usr/local/bin/pythonx is linked to this version
        install_links_if_our_fw "python${PYMAJOR}" \
                                    "pip${PYMAJOR}"

        # Create pip and easy_install link if /usr/local/bin/python
        #   is linked to this version
        install_links_if_our_fw "python" \
                                    "pip" "easy_install"
    )
fi
exit 0
